---
title: A Diary of Writing a RISC-V Hypervisor
date: 2025-05-15
---

To implement a seamless Linux integration into Starina, I decided to go with a Linux lightweight VM approach similar to WSL2. This means I need to implement a hypervisor that can run Linux.

I had [implemented an Intel VT-x based hypervisor](/blog/implementing-hypervisor-on-resea) before, but this time I wanted to try something different: RISC-V H-extension based hypervisor!

This post is a diary of my journey of writing a RISC-V hypervisor incrementally.

## RISC-V H-extension

RISC-V H-extension introduces new CPU modes and some more CSRs (so-called control registers) to implement hardware-assisted virtualization. Its design is similar to Intel VT-x in the sense that both host and guest modes have their own kernel mode and user mode. This design makes it easy to run host OS along with guests, that is, guests behave as normal host processes (e.g. QEMU and Firecracker).

## How can I test a hypervisor on macOS?

Unlike Linux KVM-based hypervisors (more specifically, virtual machine monitors), Starina is a new operating system and has been tested on QEMU.

In this case, you typically need to use nested virtualization where the hardware-assisted virtualization is emulated by the host OS. That's how I did it for Intel VT-x.

Here's a great news: QEMU itself can emulate RISC-V H-extension! You just need to add `-cpu rv64,h=true` to the QEMU command line. I presume this is thanks to RISC-V's simplicity and designers' foresight (and of course QEMU developers' effort!).

Having a software emulation in QEMU is a key enabler when you're writing a new operating system from scratch because you can attach GDB to QEMU to debug the OS.

## Step 1: Entering the guest

The first thing to do is to enter the guest state. In RISC-V, guest kernel mode is called VS-mode. In RISC-V, you just fill few CSRs. Specifically, `hstatus.SPV` should be set to 1 before `sret` instruction:

![first-inst-guest-page-fault](/images/riscv-hypervisor/first-inst-guest-page-fault.png)

The kernel panicked with an interesting error name: *instruction **guest**-page fault*. Yes, CPU has entered the guest mode!

## Step 2: First `ecall`

The next step is to run something in the guest mode. Let's start with a simple `ecall`:

```rust
const BOOT_CODE: &[u8] = &[
    0x73, 0x00, 0x00, 0x00, // ecall
];
```

To make it work, we need to prepare the guest's page table which maps the guest-physical address to the host-physical address so that the CPU can read the instructions in `BOOT_CODE`.

RISC-V defines another paging modes called Sv39x4/Sv48x4/Sv57x4, and they're mostly identical to Sv39/Sv48/Sv57. The only caveat is U bit needs to be set to 1 for kernel pages too.

Once `hgatp` is set, I got another trap reason:

![first ecall](/images/riscv-hypervisor/first-ecall.png)

## Step 3: Hello World from guest!

Now we're ready to run a Hello World program. I wrote a simple program in assembly:

```
.section .text
.global _start

_start:
    li a0, 'H'
    li a7, 1
    ecall

    li a0, 'i'
    li a7, 1
    ecall

    li a0, '!'
    li a7, 1
    ecall

    li a0, '\n'
    li a7, 1
    ecall

    unimp
```

This assumes hypervisor's ecall handler implements the SBI, a RISC-V's BIOS interface. This snippet calls so-called `putchar` API and finally calls an invalid instruction (`unimp`) to trigger a trap.

Building this tiny guest OS is easy:

```
$ clang --target=riscv64 -march=rv64g -nostdlib -Wl,-Ttext=0x80200000 guest.S -o guest.elf
$ llvm-objcopy -O binary guest.elf guest.bin
```

And it works!

![minimal hello world](/images/riscv-hypervisor/minimal-hello-world.png)

## Step 4: Building Linux

##

hedeleg - Linux uses stvec as a hack

## Device Tree

![null dereference in device tree](/images/riscv-hypervisor/null-dereference-in-device-tree.png)

```
$ gobjdump -d linux/vmlinux | grep -A 5 801cace8 | head
ffffffff801cace8 <__pi_fdt32_ld>:
ffffffff801cace8:	00054783          	lbu	a5,0(a0)  <-- null deferecence here!
ffffffff801cacec:	00154703          	lbu	a4,1(a0)
ffffffff801cacf0:	0187979b          	slliw	a5,a5,0x18
```

## Debugging page faults after enabling MMU

```
epc:0xffffffff80005354, tval:0x0000000000000000, desc=hypervisor_ecall
epc:0x0000000080228144, tval:0xffffffff80263dc8, desc=store_page_fault
epc:0x0000000080227694, tval:0x00000000000000ab, desc=store_page_fault
epc:0x0000000080228144, tval:0xffffffff80263b78, desc=store_page_fault
epc:0x0000000080227694, tval:0x00000000000000ab, desc=store_page_fault
epc:0x0000000080228144, tval:0xffffffff80263928, desc=store_page_fault
epc:0x0000000080227694, tval:0x00000000000000ab, desc=store_page_fault
epc:0x0000000080228144, tval:0xffffffff802636d8, desc=store_page_fault
```

sp - do not forget to set sp register (or check your kernel's pc too)

## `rdtime` support

> hcounteren register is clear, attempts to read the cycle, time, instret, or hpmcounter n register while V=1 will cause a virtual-instruction exception

`hcounteren`, Hypervisor Counter-Enable Register, needs to be set to enable `rdtime` in guest.

```rust
hcounteren |= 0xffff_ffff;
```


### `wfi`

```
ffffffff80170dba <arch_cpu_idle>:
ffffffff80170dba:   0ff0000f            fence
ffffffff80170dbe:   10500073            wfi
ffffffff80170dc2:   8082                ret
```

`VTW=1` in `hstatus`

## `sbi_set_timer`

`hideleg`

## Sstc extension

![linux-hello-world](/images/riscv-hypervisor/linux-hello-world.png)


## MMIO support

> A guest physical address written to htval is shifted right by 2 bits to accommodate addresses
wider than the current XLEN

> htinst could be compressed instruction

## Virtio-fs

![virtio-fs](/images/riscv-hypervisor/hello-from-virtio-fs.png)

## So how can I use the hypervisor?

```rust
use starina::lx::Command;

let file_ch = fs_server.open("/...").await;

let stdin = Writer::from("hello");
let stdout = Reader::from(|buf| {
  println!("stdout: {}", buf);
});

let cmd =
    Command::new("cowsay")
        .arg("/tmp/hello.txt")
        .stdin(stdin)
        .stdout(stdout)
        // Connect to Starina's FS
        .mount("/tmp/hello.txt", file_ch);
        // Export a TCP port
        .expose(Port::Tcp {
          host: 80,  // Port in Starina
          guest: 80, // Port in Linux
        });

// Boot a lightweight Linux VM and spawn cowsay(1).
cmd.spawn();
```

## Fun Tips

### RISC-V extensions are more like "patches"

That is, they may change the behavior. Even if you don't explicitly enable them.

https://github.com/riscv-software-src/riscv-unified-db

### GDB can debug both hypervisor/guest worlds!

Starina supports Unikernel-like mode, where the microkernel and apps are built into a single ELF executable. This is not only for performance, but also for debugging.

Here's a `gdbinit` script which enabled me to watch VMM, hypervisor in Starina kernel, and the Linux kernel in guest:

```
# Load Starina (hypervisor's) debug info
file build/kernel/debug/kernel

# Load Linux (guest's) debug info
add-symbol-file apps/servers/lx/linux/vmlinux
```

And look! You're seeing the guest's kernel stack trace!

![gdb](/images/riscv-hypervisor/you-can-attach-gdb.png)

BTW, this is why I haven't yet implemented stack traces in Starina: you just need to attach the GDB and type `bt`.
